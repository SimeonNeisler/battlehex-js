

//-------------------------------------------------------------------------------
// Users
//-------------------------------------------------------------------------------

path /users {
    read() = true;
}

path /users/$userId is User {
    write() = (doesExist(this) && prior(this).id == auth.uid && this.id == auth.uid) || (doesNotExist(this) && this.id == auth.uid);
    validate() = this.id == $userId;
}

type User extends Entity {
    firstName: String,
    lastName: String,
    userName: String,
    id: Uid
}

type Uid extends String {
    validate() = isUid(this);
}

//1e2b7288-45f5-4f98-9f81-1ab192245a7b

function isUid(value) {
    return value.test(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/);
}

function isCurrentUser(userId) {
    return auth.uid == userId;
}

function isExistingUserId(userId) {
    return root.users[userId] != null;
}


//-------------------------------------------------------------------------------
// Roles
//-------------------------------------------------------------------------------

path /roles/$userId {
    read() = isCurrentUser($userId);
    write() = isCurrentUserAdmin();
}

path /roles/$userId/$roleName is Boolean {
    validate() = $roleName.isString();
}

function isCurrentUserAdmin() {
    return isUserAdmin(auth.uid);
}

function isUserAdmin(userId) {
    return root.roles[userId].admin == true;
}


//-------------------------------------------------------------------------------
// Games
//-------------------------------------------------------------------------------

path /games/$gameId is Game {
    read() = (isCurrentUserGamePlayer(this));
    write() = (doesExist(this) && isCurrentUserGamePlayer(this) && prior(this).players[auth.uid].userId == auth.uid ||  doesNotExist(this) && this.players[auth.uid].userId == auth.uid);
}

type Game extends Entity {
        id: GameId,
        name: String
}

type ExistingGameId extends Id {
    return isExistingGameId(this);
}

function isExistingGameId(gameId) {
    return root.games[gameId] != null;
}


//-------------------------------------------------------------------------------
// GamePlayers
//-------------------------------------------------------------------------------

path /games/$gameId/players/$userId is GamePlayer {
        read() = isCurrentUserGamePlayer($gameId);
}
path /games/$gameId/players/$userId/id {
    validate() = this == $userId;
}

type GamePlayer extends Entity {
    userId: UserId
}

function isCurrentUserGamePlayer(gameId) {
    return isUserGamePlayer(gameId, auth.uid);
}

function isUserGamePlayer(gameId, userId) {
    return root.games[gameId].players[userId].userId == userId;
}


//-------------------------------------------------------------------------------
// Decks
//-------------------------------------------------------------------------------

path /decks/$deckId is Deck {
    read() = doesCurrentUserOwnObject(this);
    write() = (doesExist(this) && doesCurrentUserOwnObject(this) && willCurrentUserOwnObject(this)) || (doesNotExist(this) && willCurrentUserOwnObject(this));
}

path /decks/$deckId/cards/$cardIndex is ExistingCardId {
    validate() = ($cardIndex >= 0 && $cardIndex < 30);
}

type Deck extends Entity {
    deckName: String,
    userId: String
}

type ExistingDeckId extends Id {
    return isExistingDeckId(this);
}

function isExistingDeckId(deckId) {
    return root.decks[deckId] != null;
}

function isCurrentUsersDeck(deckId) {
    return auth.uid == root.decks[deckId].userId;
}

//-------------------------------------------------------------------------------
// Cards
//-------------------------------------------------------------------------------

path /store {
        read() = true;
}

path /store/$storeCardId is storeCard {
        read() = true;
}

type storeCard extends Entity {
        cardName: String,
        cardCost: Number,
        cardStrength: Number,
        cardHP: Number,
        cardRange: Number,
        cardDeployCost: Number
}

path /decks/$userCardId is userCard {
        read() = doesCurrentUserOwnObject(this);
}

type userCard {
        userId: String,
        cardId: String,
        cardName: String,
        cardStrength: Number,
        cardHP: Number,
        cardRange: Number,
        cardDeployCost: Number
}


//-------------------------------------------------------------------------------
// Indexes
//-------------------------------------------------------------------------------

path /indexes/userIdToGameIds/$userId {
    validate() = isExistingUserId($userId);
    read() = isCurrentUser($userId);
}

path /indexes/userIdToGameIds/$userId/$gameId is ExistingGameId {
    write() = isCurrentUserGamePlayer($gameId) && isCurrentUser($userId);
}


path /games/gameCards {
        read() = false;
        write() = false;
}

path /games/gameCards/$gameCardId is GameCard {
        read() = (doesCurrentUserOwnObject(this));
        write() = false;
}

type GameCard extends Entity {
        gameId: String,
        userId: String,
        cardId: String,
        cardName: String,
        cardStrength: Number,
        cardHP: Number,
        cardRange: Number,
        cardDeployCost: Number
}

path /games/gameDecks {
}

path /games/gameDecks/$gameDeck is gameDeck {
        read() = (doesCurrentUserOwnObject(this));
}

type gameDeck extends Entity {
        userId: String,
        gameId: String,
        deckName: String,
        deckSize: Number,
        deckCards: []
}

path /games/hands {
        read() = false;
        write() = false;
}

path /games/hands/$hand is hand{
        read() = (doesCurrentUserOwnObject(this));
        write() = (willCurrentUserOwnObject(this) && doesCurrentUserOwnObject(this) && isUsersGameTurn(this.gameId, this.userId) && !isCurrentGameTurnComplete(this.gameId));
        validate() = (prior(this).numberCards >= this.numberCards && prior(this).numberCards <= this.numberCards + 3);
}

type hand extends Entity {
        gameId: String,
        userId: String,
        handSize: Number,
        handContents: []
}

path /games/discardPiles {
        read() = false;
        write() = false;
}

path /games/disardPiles/$discardPile is discardPile {
        read() = false;
        write() = (willCurrentUserOwnObject(this) && doesCurrentUserOwnObject(this) && isUsersGameTurn(this.userId, this.gameId) && !isCurrentGameTurnComplete(this.gameId));
}

type discardPile extends Entity {
        userId: String,
        gameId: String,
        contents: []
}

path /games/maps/$map is Map {
        read() = isCurretUserGamePlayer(this.gameId);
}

path /games/maps/$map/tiles {
}

path /games/maps/$map/tiles/$tiles is MapTile {
        read() = isCurretUserGamePlayer($gameId);
        write() == (isCurrentUserGamePlayer(root.games.maps[map].gameId) && isCurrentUsersGameTurn(root.games.maps[map].gameId) && !isCurrentGameTurnComplete(root.games.maps[map].gameId));
        validate() = (prior(this).terrain == this.terrain && prior(this).resource == resource && prior(this).resourceQuantity == this.resourceQuantity);
}

type Map extends Entity {
        gameId: String,
        tiles: []
}

type MapTile extends Entity {
        tileNum: Number,
        terrain: String,
        resource: String,
        resourceQuantity: Number,
        boardUnit: boardUnit
}

path /states/games/$gameId/info is GameState {
    read() = isUserGamePlayer($gameId);
}

type GameState {
    gameId: GameId,
    currentGameTurnId: GameTurnStateId
}

function isCurrentUsersGameTurn(gameId) {
    return isUsersGameTurn(gameId, auth.uid);
}

function getCurrentGameTurnId(gameId) {
    return root.states.games[gameId].info.currentGameTurnId;
}

function getCurrentGameTurn(gameId) {
    return root.states.games[gameId].turns[getCurrentGameTurnId(gameId)];
}

function isUsersGameTurn(gameId, userId) {
    return getCurrentGameTurn(gameId).userId == userId;
}

function isCurrentGameTurnComplete(gameId) {
    return getCurrentGameTurn(gameId).complete;
}

function isGameTurnComplete(gameId, turnId) {
    return root.states.games[gameId].turns[turnId].complete;
}

path /states/games/$gameId/turns/$turnId is GameTurnState {
    read() = isCurrentUserGamePlayer($gameId);
    write() = !isGameTurnComplete($gameId, $turnId);
}

path /states/games/$gameId/turns/$turnId/id {
    validate() = this == $turnId;
}

type GameTurnState extends Entity {
    gameId: GameId,
    userId: UserId,
    complete: TurnComplete
}
states/games/$gameId/turns/$turnId/$TurnComplete is TurnComplete {
    read() = isUserGamePlayer($gameId);
    write() = isUsersGameTurn($gameId, auth.uid);
}

type TurnComplete extend Boolean {
    validate() {
        return (doesNotExist() && this == false)
            || (doesExist() && this == true)
    }
}

path /states/games/$gameId/drawPiles/$drawPileId is GameDrawPileState {
    read() = doesCurrentUserOwnObject(this);
    write() = (willCurrentUserOwnObject(this) && doesCurrentUserOwnObject(this) && isUsersGameTurn(this.gameId, this.userId) && this.gameId.info.gameTurnState.TurnComplete == false);
    validate() = (prior(this).numberCards >= this.numberCards && prior(this).numberCards <= this.numberCards + 3);
}

type GameDrawPileState {
    gameId: GameId,
    userId: UserId,
    numberCards: Number;
    drawPileIndex: Number;
}

function isUsersDrawPile(gameId, handId, userId) {
   return root.states.games[gameId].drawPiles[drawPileId].userId == userId;
}

function isCurrentDrawPileIndex(gameId, drawPileId, drawPileIndex) {
   return root.states.games[gameId].drawPiles[drawPileId]. drawPileIndex == drawPileIndex;
}

path /states/games/$gameId/deckCards/$drawPileId/$drawPileIndex is GameDrawPileCard  {
   read() = isUsersDrawPile($gameId, $drawPileId, auth.uid) && isCurrentDrawPileIndex($gameId, $drawPileId, $drawPileIndex);
}

path /states/games/$gameId/deckCards/$drawPileId/$drawPileIndex/index  {
   validate() = this == $drawPileIndex;
}

type GameDrawPileCard {
    index: Number,
    name: String
}


//-------------------------------------------------------------------------------
// Utils
//-------------------------------------------------------------------------------

type Entity {
    createdAt: Number,
    updatedAt: Number
}

type Id extends String {
    TODO
}

function doesNotExist(value) {
    return prior(value) == null;
}

function doesExist(value) {
    return prior(value) != null;
}

function willCurrentUserOwnObject(object) {
    return willUserOwnObject(object, auth.uid);
}

function willUserOwnObject(object, userId) {
   return object.userId == userId;
}

function doesCurrentUserOwnObject(object) {
    return doesUserOwnObject(object, auth.uid);
}
function doesUserOwnObject(object, userId) {
    return prior(object).userId == userId);
}

        map: Map,
        gameCards: [],
        gameDecks: [],
        hands: [],
        drawPiles: [],
        discardPiles: []
