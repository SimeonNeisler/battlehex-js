
//-------------------------------------------------------------------------------
// Users
//-------------------------------------------------------------------------------

path /users {
    read() = true;
}

path /users/$userId is User {
    write() = (doesExist(this) && prior(this).id == auth.uid && this.id == auth.uid) || (doesNotExist(this) && this.id == auth.uid);
    validate() = this.id == $userId;
}

type User extends TimeStamped {
    firstName: String,
    lastName: String,
    userName: String,
    id: Uid
}

type Uid extends String {
    validate() = isUid(this);
}

type ExistingUserId extends Uid {
    return isExistingUserId(this);
}

//1e2b7288-45f5-4f98-9f81-1ab192245a7b

function isUid(value) {
    return value.test(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/);
}

function isCurrentUser(userId) {
    return auth.uid == userId;
}

function isExistingUserId(userId) {
    return root.users[userId] != null;
}


//-------------------------------------------------------------------------------
// Roles
//-------------------------------------------------------------------------------

path /roles/$userId {
    read() = isCurrentUser($userId);
    write() = isCurrentUserAdmin();
}

path /roles/$userId/$roleName is Boolean {
    validate() = $roleName.isString();
}

function isCurrentUserAdmin() {
    return isUserAdmin(auth.uid);
}

function isUserAdmin(userId) {
    return root.roles[userId].admin == true;
}


//-------------------------------------------------------------------------------
// Games
//-------------------------------------------------------------------------------

path /games/$gameId is Game {
    read() = (isCurrentUserGamePlayer(this));
    write() = (doesExist(this) && isCurrentUserGamePlayer(this) && prior(this).players[auth.uid].userId == auth.uid ||  doesNotExist(this) && this.players[auth.uid].userId == auth.uid);
}

type Game extends Entity {
        name: String
}

type ExistingGameId extends Id {
    return isExistingGameId(this);
}

function isExistingGameId(gameId) {
    return root.games[gameId] != null;
}


//-------------------------------------------------------------------------------
// GamePlayers
//-------------------------------------------------------------------------------

path /games/$gameId/players/$userId is GamePlayer {
    read() = isCurrentUserGamePlayer($gameId);
}
path /games/$gameId/players/$userId/id {
    validate() = this == $userId;
}

type GamePlayer extends TimeStamped {
    userId: UserId
}

function isCurrentUserGamePlayer(gameId) {
    return isUserGamePlayer(gameId, auth.uid);
}

function isUserGamePlayer(gameId, userId) {
    return root.games[gameId].players[userId].userId == userId;
}


//-------------------------------------------------------------------------------
// Decks
//-------------------------------------------------------------------------------

path /decks/$deckId/info is Deck {
    read() {doesCurrentUserOwnObject(this)}
    write() {doesExist(this) && doesCurrentUserOwnObject(this) && willCurrentUserOwnObject(this)) || (doesNotExist(this) && willCurrentUserOwnObject(this)}
}

type Deck extends Entity {
    deckName: String,
    userId: String
}

type ExistingDeckId extends Id {
    return isExistingDeckId(this);
}

function isExistingDeckId(deckId) {
    return root.decks[deckId] != null;
}

function isCurrentUsersDeck(deckId) {
    return auth.uid == root.decks[deckId].info.userId;
}

function doesUserIdOwnDeckId(deckId, userId) {
    return (root.decks[deckId].info.userId == userId);
}

function doesCurrentUserOwnDeckId(deckId) {
    return doesUserIdOwnDeckId(deckId, auth.uid);
}


//-------------------------------------------------------------------------------
// Cards
//-------------------------------------------------------------------------------

path /cards {
        read() {true}
}

path /cards/{cardId} is Card {
        read() { true }
        write() { false }
        validate { this.id == cardId }
}

type Card extends Entity {
        cardName: String,
        cardCost: Number,
        cardStrength: Number,
        cardHP: Number,
        cardRange: Number,
        cardDeployCost: Number
}

type ExistingCardId extends Id {
    return isExistingCardId(this);
}

function isExistingCardId(cardId) {
    return root.cards[cardId] != null;
}


//-------------------------------------------------------------------------------
// UserCards
//-------------------------------------------------------------------------------

path /userCards/{userId}/{cardId} is UserCard {
        read() { doesCurrentUserOwnObject(this) }
        write() { false }
        validate() {this.userId == userId && this.cardId == cardId}
}

type UserCard extends TimeStamped {
        userId: ExistingUserId,
        cardId: ExistingCardId,
        count: Number
}

function doesUserIdOwnCardId(cardId, userId) {
    return (root.userCards[userId][cardId] != null);
}

function doesCurrentUserOwnCardId(cardId) {
    return doesUserIdOwnCardId(cardId, auth.uid);
}

function doesUserOwnCardCount(userId, cardId, count) {
    return (root.userCards[userId][cardId].count >= count);
}


//-------------------------------------------------------------------------------
// DeckCards
//-------------------------------------------------------------------------------

path /decks/{deckId}/cards/{cardId} is DeckCard {
    read() { doesCurrentUserOwnObject(this) }
    write() {
        doesCurrentUserOwnCardId(cardId) &&
        doesCurrentUserOwnDeckId(deckId)
    }
    validate() {
        this.deckId == deckId && this.cardId == cardId
    }
}

type DeckCard extends TimeStamped {
    deckId: ExistingDeckId,
    cardId: ExistingCardId,
    index: Number,
    total: Number
}

function willCardExistInDeck(newRoot, cardId, deckId) {
    newRoot.decks[deckId].cards[cardId] != null;
}


//-------------------------------------------------------------------------------
// DeckCardsIndex
//-------------------------------------------------------------------------------

path /decks/{deckId}/cardsIndex/{index} is DeckCardIndex {
    validate() {
        index >= 0 && index < 30 &&
        willCardExistInDeck(this.parent().parent().parent().parent(), this.cardId, deckId)
    }
}

path /decks/{deckId}/cardsIndex/{index}/index {
    validate() { this == index}
}

type DeckCardIndex {
    index: number,
    cardId: ExistingCardId,

}

function willCardExistInDeckIndex(newRoot, cardId, deckId) {
    newRoot.decks[deckId].cardsIndex[index]cardId != null;
}


//-------------------------------------------------------------------------------
// Indexes
//-------------------------------------------------------------------------------

path /indexes/userIdToGameIds/$userId {
    validate() = isExistingUserId($userId);
    read() = isCurrentUser($userId);
}

path /indexes/userIdToGameIds/$userId/$gameId is ExistingGameId {
    write() = isCurrentUserGamePlayer($gameId) && isCurrentUser($userId);
}


//-------------------------------------------------------------------------------
// GameCards
//-------------------------------------------------------------------------------

path /games/gameCards {
        read() = false;
        write() = false;
}

path /games/gameCards/$gameCardId is GameCard {
        read() = (doesCurrentUserOwnObject(this));
        write() = false;
}

type GameCard extends Entity {
        gameId: String,
        userId: String,
        cardId: String,
        cardName: String,
        cardStrength: Number,
        cardHP: Number,
        cardRange: Number,
        cardDeployCost: Number
}


//-------------------------------------------------------------------------------
// GameDecks
//-------------------------------------------------------------------------------

path /games/gameDecks {
}

path /games/gameDecks/$gameDeck is gameDeck {
}

type gameDeck extends Entity {
        userId: String,
        gameId: String,
        deckName: String,
        deckSize: Number,
        deckCards: []
}


//-------------------------------------------------------------------------------
// GameHands
//-------------------------------------------------------------------------------

path /games/hands {
        read() = false;
        write() = false;
}

path /games/hands/$hand is hand{
        read() = (doesCurrentUserOwnObject(this));
        write() = (willCurrentUserOwnObject(this) && doesCurrentUserOwnObject(this) && isUsersGameTurn(this.gameId, this.userId) && !isCurrentGameTurnComplete(this.gameId));
        validate() = (prior(this).numberCards >= this.numberCards && prior(this).numberCards <= this.numberCards + 3);
}

type GameHand extends Entity {
        gameId: String,
        userId: String,
        handSize: Number,
        handContents: []
}

path /games/discardPiles {
}


//-------------------------------------------------------------------------------
// GameDiscardPiles
//-------------------------------------------------------------------------------

path /games/disardPiles/$discardPile is discardPile {
        write() = (willCurrentUserOwnObject(this) && doesCurrentUserOwnObject(this) && isUsersGameTurn(this.userId, this.gameId) && !isCurrentGameTurnComplete(this.gameId));
}

type DiscardPile extends Entity {
        userId: String,
        gameId: String,
        contents: []
}


//-------------------------------------------------------------------------------
// GameMaps
//-------------------------------------------------------------------------------

path /games/maps/$map is Map {
        read() = isCurretUserGamePlayer(this.gameId);
}

path /games/maps/$map/tiles {
}

path /games/maps/$map/tiles/$tiles is MapTile {
        read() = isCurretUserGamePlayer($gameId);
        write() == (isCurrentUserGamePlayer(root.games.maps[map].gameId) && isCurrentUsersGameTurn(root.games.maps[map].gameId) && !isCurrentGameTurnComplete(root.games.maps[map].gameId));
        validate() = (prior(this).terrain == this.terrain && prior(this).resource == resource && prior(this).resourceQuantity == this.resourceQuantity);
}

type Map extends Entity {
        gameId: String,
        tiles: []
}

type MapTile extends Entity {
        tileNum: Number,
        terrain: String,
        resource: String,
        resourceQuantity: Number,
        boardUnit: boardUnit
}


//-------------------------------------------------------------------------------
// States
//-------------------------------------------------------------------------------

path /states/games/$gameId/info is GameState {
    read() = isUserGamePlayer($gameId);
}

type GameState {
    gameId: GameId,
    currentGameTurnId: GameTurnStateId
}

function isCurrentUsersGameTurn(gameId) {
    return isUsersGameTurn(gameId, auth.uid);
}

function getCurrentGameTurnId(gameId) {
    return root.states.games[gameId].info.currentGameTurnId;
}

function getCurrentGameTurn(gameId) {
    return root.states.games[gameId].turns[getCurrentGameTurnId(gameId)];
}

function isUsersGameTurn(gameId, userId) {
    return getCurrentGameTurn(gameId).userId == userId;
}

function isCurrentGameTurnComplete(gameId) {
    return getCurrentGameTurn(gameId).complete;
}

function isGameTurnComplete(gameId, turnId) {
    return root.states.games[gameId].turns[turnId].complete;
}

path /states/games/$gameId/turns/$turnId is GameTurnState {
    read() = isCurrentUserGamePlayer($gameId);
    write() = !isGameTurnComplete($gameId, $turnId);
}

path /states/games/$gameId/turns/$turnId/id {
    validate() = this == $turnId;
}

type GameTurnState extends Entity {
    gameId: GameId,
    userId: UserId,
    complete: TurnComplete
}
states/games/$gameId/turns/$turnId/$TurnComplete is TurnComplete {
    read() = isUserGamePlayer($gameId);
    write() = isUsersGameTurn($gameId, auth.uid);
}

type TurnComplete extend Boolean {
    validate() {
        return (doesNotExist() && this == false)
            || (doesExist() && this == true)
    }
}


//-------------------------------------------------------------------------------
// GameDrawPiles
//-------------------------------------------------------------------------------

path /states/games/$gameId/drawPiles/$drawPileId is GameDrawPileState {
    read() = doesCurrentUserOwnObject(this);
    write() = (willCurrentUserOwnObject(this) && doesCurrentUserOwnObject(this) && isUsersGameTurn(this.gameId, this.userId) && !isCurrentGameTurnComplete(this.gameId));
    validate() = (prior(this).numberCards >= this.numberCards && prior(this).numberCards <= this.numberCards + 3);
}

type GameDrawPileState {
    gameId: GameId,
    userId: UserId,
    numberCards: Number;
    drawPileIndex: Number;
}

function isUsersDrawPile(gameId, handId, userId) {
   return root.states.games[gameId].drawPiles[drawPileId].userId == userId;
}

function isCurrentDrawPileIndex(gameId, drawPileId, drawPileIndex) {
   return root.states.games[gameId].drawPiles[drawPileId]. drawPileIndex == drawPileIndex;
}

path /states/games/$gameId/deckCards/$drawPileId/$drawPileIndex is GameDrawPileCard  {
   read() = isUsersDrawPile($gameId, $drawPileId, auth.uid) && isCurrentDrawPileIndex($gameId, $drawPileId, $drawPileIndex);
}

path /states/games/$gameId/deckCards/$drawPileId/$drawPileIndex/index  {
   validate() = this == $drawPileIndex;
}

type GameDrawPileCard {
    index: Number,
    name: String
}


//-------------------------------------------------------------------------------
// Utils
//-------------------------------------------------------------------------------

type Entity extends TimeStamped {
    id: Id
}

type TimeStamped {
    createdAt: Number,
    updatedAt: Number
}

type Id extends String {
    TODO
}

function doesNotExist(value) {
    return prior(value) == null;
}

function doesExist(value) {
    return prior(value) != null;
}

function willCurrentUserOwnObject(object) {
    return willUserOwnObject(object, auth.uid);
}

function willUserOwnObject(object, userId) {
   return object.userId == userId;
}

function doesCurrentUserOwnObject(object) {
    return doesUserOwnObject(object, auth.uid);
}
function doesUserOwnObject(object, userId) {
    return prior(object).userId == userId);
}

        map: Map,
        gameCards: [],
        gameDecks: [],
        hands: [],
        drawPiles: [],
        discardPiles: []
